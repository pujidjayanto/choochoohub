// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"github.com/pujidjayanto/choochoohub/user-api/pkg/kafkaproducer"
	"sync"
)

// Ensure, that ProducerMock does implement kafkaproducer.Producer.
// If this is not the case, regenerate this file with moq.
var _ kafkaproducer.Producer = &ProducerMock{}

// ProducerMock is a mock implementation of kafkaproducer.Producer.
//
//	func TestSomethingThatUsesProducer(t *testing.T) {
//
//		// make and configure a mocked kafkaproducer.Producer
//		mockedProducer := &ProducerMock{
//			SendMessageFunc: func(ctx context.Context, topic string, partition int, message []byte) error {
//				panic("mock out the SendMessage method")
//			},
//		}
//
//		// use mockedProducer in code that requires kafkaproducer.Producer
//		// and then make assertions.
//
//	}
type ProducerMock struct {
	// SendMessageFunc mocks the SendMessage method.
	SendMessageFunc func(ctx context.Context, topic string, partition int, message []byte) error

	// calls tracks calls to the methods.
	calls struct {
		// SendMessage holds details about calls to the SendMessage method.
		SendMessage []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Topic is the topic argument value.
			Topic string
			// Partition is the partition argument value.
			Partition int
			// Message is the message argument value.
			Message []byte
		}
	}
	lockSendMessage sync.RWMutex
}

// SendMessage calls SendMessageFunc.
func (mock *ProducerMock) SendMessage(ctx context.Context, topic string, partition int, message []byte) error {
	if mock.SendMessageFunc == nil {
		panic("ProducerMock.SendMessageFunc: method is nil but Producer.SendMessage was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Topic     string
		Partition int
		Message   []byte
	}{
		Ctx:       ctx,
		Topic:     topic,
		Partition: partition,
		Message:   message,
	}
	mock.lockSendMessage.Lock()
	mock.calls.SendMessage = append(mock.calls.SendMessage, callInfo)
	mock.lockSendMessage.Unlock()
	return mock.SendMessageFunc(ctx, topic, partition, message)
}

// SendMessageCalls gets all the calls that were made to SendMessage.
// Check the length with:
//
//	len(mockedProducer.SendMessageCalls())
func (mock *ProducerMock) SendMessageCalls() []struct {
	Ctx       context.Context
	Topic     string
	Partition int
	Message   []byte
} {
	var calls []struct {
		Ctx       context.Context
		Topic     string
		Partition int
		Message   []byte
	}
	mock.lockSendMessage.RLock()
	calls = mock.calls.SendMessage
	mock.lockSendMessage.RUnlock()
	return calls
}
