// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"github.com/pujidjayanto/choochoohub/user-api/dto"
	"github.com/pujidjayanto/choochoohub/user-api/usecase"
	"sync"
)

// Ensure, that UserUsecaseMock does implement usecase.UserUsecase.
// If this is not the case, regenerate this file with moq.
var _ usecase.UserUsecase = &UserUsecaseMock{}

// UserUsecaseMock is a mock implementation of usecase.UserUsecase.
//
//	func TestSomethingThatUsesUserUsecase(t *testing.T) {
//
//		// make and configure a mocked usecase.UserUsecase
//		mockedUserUsecase := &UserUsecaseMock{
//			SigninFunc: func(c context.Context, req dto.SigninRequest) (*dto.SigninResponse, error) {
//				panic("mock out the Signin method")
//			},
//			SignupFunc: func(c context.Context, req dto.SignupRequest) error {
//				panic("mock out the Signup method")
//			},
//		}
//
//		// use mockedUserUsecase in code that requires usecase.UserUsecase
//		// and then make assertions.
//
//	}
type UserUsecaseMock struct {
	// SigninFunc mocks the Signin method.
	SigninFunc func(c context.Context, req dto.SigninRequest) (*dto.SigninResponse, error)

	// SignupFunc mocks the Signup method.
	SignupFunc func(c context.Context, req dto.SignupRequest) error

	// calls tracks calls to the methods.
	calls struct {
		// Signin holds details about calls to the Signin method.
		Signin []struct {
			// C is the c argument value.
			C context.Context
			// Req is the req argument value.
			Req dto.SigninRequest
		}
		// Signup holds details about calls to the Signup method.
		Signup []struct {
			// C is the c argument value.
			C context.Context
			// Req is the req argument value.
			Req dto.SignupRequest
		}
	}
	lockSignin sync.RWMutex
	lockSignup sync.RWMutex
}

// Signin calls SigninFunc.
func (mock *UserUsecaseMock) Signin(c context.Context, req dto.SigninRequest) (*dto.SigninResponse, error) {
	if mock.SigninFunc == nil {
		panic("UserUsecaseMock.SigninFunc: method is nil but UserUsecase.Signin was just called")
	}
	callInfo := struct {
		C   context.Context
		Req dto.SigninRequest
	}{
		C:   c,
		Req: req,
	}
	mock.lockSignin.Lock()
	mock.calls.Signin = append(mock.calls.Signin, callInfo)
	mock.lockSignin.Unlock()
	return mock.SigninFunc(c, req)
}

// SigninCalls gets all the calls that were made to Signin.
// Check the length with:
//
//	len(mockedUserUsecase.SigninCalls())
func (mock *UserUsecaseMock) SigninCalls() []struct {
	C   context.Context
	Req dto.SigninRequest
} {
	var calls []struct {
		C   context.Context
		Req dto.SigninRequest
	}
	mock.lockSignin.RLock()
	calls = mock.calls.Signin
	mock.lockSignin.RUnlock()
	return calls
}

// Signup calls SignupFunc.
func (mock *UserUsecaseMock) Signup(c context.Context, req dto.SignupRequest) error {
	if mock.SignupFunc == nil {
		panic("UserUsecaseMock.SignupFunc: method is nil but UserUsecase.Signup was just called")
	}
	callInfo := struct {
		C   context.Context
		Req dto.SignupRequest
	}{
		C:   c,
		Req: req,
	}
	mock.lockSignup.Lock()
	mock.calls.Signup = append(mock.calls.Signup, callInfo)
	mock.lockSignup.Unlock()
	return mock.SignupFunc(c, req)
}

// SignupCalls gets all the calls that were made to Signup.
// Check the length with:
//
//	len(mockedUserUsecase.SignupCalls())
func (mock *UserUsecaseMock) SignupCalls() []struct {
	C   context.Context
	Req dto.SignupRequest
} {
	var calls []struct {
		C   context.Context
		Req dto.SignupRequest
	}
	mock.lockSignup.RLock()
	calls = mock.calls.Signup
	mock.lockSignup.RUnlock()
	return calls
}
